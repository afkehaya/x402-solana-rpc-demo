import * as outputs from "../types/output";
import * as enums from "../types/enums";
export declare namespace agave {
    interface Flags {
        accountIndex?: string[];
        accountIndexExcludeKey?: string[];
        accountIndexIncludeKey?: string[];
        accountShrinkPath?: string[];
        accountsDbCacheLimitMb?: number;
        accountsDbTestHashCalculation?: boolean;
        accountsHashCachePath?: string;
        accountsIndexBins?: number;
        accountsIndexPath?: string[];
        accountsIndexScanResultsLimitMb?: number;
        accountsShrinkOptimizeTotalSpace?: boolean;
        accountsShrinkRatio?: string;
        allowPrivateAddr?: boolean;
        authorizedVoter?: string[];
        bindAddress?: string;
        blockProductionMethod?: string;
        blockVerificationMethod?: string;
        checkVoteAccount?: string;
        contactDebugInterval?: number;
        cuda?: boolean;
        debugKey?: string[];
        devHaltAtSlot?: number;
        disableBankingTrace?: boolean;
        dynamicPortRange?: string;
        enableBankingTrace?: number;
        enableBigtableLedgerUpload?: boolean;
        enableExtendedTxMetadataStorage?: boolean;
        enableRpcBigtableLedgerStorage?: boolean;
        enableRpcTransactionHistory?: boolean;
        entryPoint?: string[];
        etcdCacertFile?: string;
        etcdCertFile?: string;
        etcdDomainName?: string;
        etcdEndpoint?: string[];
        etcdKeyFile?: string;
        expectedBankHash?: string;
        expectedGenesisHash?: string;
        expectedShredVersion?: number;
        extraFlags?: string[];
        fullRpcAPI?: boolean;
        fullSnapshotArchivePath?: string;
        fullSnapshotIntervalSlots?: number;
        geyserPluginAlwaysEnabled?: boolean;
        geyserPluginConfig?: string[];
        gossipHost?: string;
        gossipPort?: number;
        gossipValidator?: string[];
        hardFork?: number[];
        healthCheckSlotDistance?: number;
        incrementalSnapshotArchivePath?: string;
        initCompleteFile?: string;
        knownValidator?: string[];
        limitLedgerSize?: number;
        log?: string;
        logMessagesBytesLimit?: number;
        maxGenesisArchiveUnpackedSize?: number;
        maximumFullSnapshotsToRetain?: number;
        maximumIncrementalSnapshotsToRetain?: number;
        maximumLocalSnapshotAge?: number;
        maximumSnapshotDownloadAbort?: number;
        minimalSnapshotDownloadSpeed?: number;
        noGenesisFetch?: boolean;
        noIncrementalSnapshots?: boolean;
        noSnapshotFetch?: boolean;
        noVoting?: boolean;
        noWaitForVoteToStartLeader: boolean;
        onlyKnownRPC?: boolean;
        privateRPC?: boolean;
        publicRpcAddress?: string;
        publicTpuAddress?: string;
        publicTpuForwardsAddress?: string;
        repairValidator?: string[];
        requireTower?: boolean;
        restrictedRepairOnlyMode?: boolean;
        rocksdbFifoShredStorageSize?: number;
        rocksdbShredCompaction?: string;
        rpcBigtableAppProfileId?: string;
        rpcBigtableInstanceName?: string;
        rpcBigtableMaxMessageSize?: number;
        rpcBigtableTimeout?: number;
        rpcBindAddress: string;
        rpcFaucetAddress?: string;
        rpcMaxMultipleAccounts?: number;
        rpcMaxRequestBodySize?: number;
        rpcNicenessAdjustment?: number;
        rpcPort: number;
        rpcPubsubEnableBlockSubscription?: boolean;
        rpcPubsubEnableVoteSubscription?: boolean;
        rpcPubsubMaxActiveSubscriptions?: number;
        rpcPubsubNotificationThreads?: number;
        rpcPubsubQueueCapacityBytes?: number;
        rpcPubsubQueueCapacityItems?: number;
        rpcPubsubWorkerThreads?: number;
        rpcScanAndFixRoots?: boolean;
        rpcSendLeaderCount?: number;
        rpcSendRetryMs?: number;
        rpcSendServiceMaxRetries?: number;
        rpcSendTransactionAlsoLeader?: boolean;
        rpcSendTransactionRetryPoolMaxSize?: number;
        rpcSendTransactionTpuPeer?: string[];
        rpcThreads?: number;
        skipPreflightHealthCheck?: boolean;
        skipSeedPhraseValidation?: boolean;
        skipStartupLedgerVerification?: boolean;
        snapshotArchiveFormat?: string;
        snapshotIntervalSlots?: number;
        snapshotPackagerNicenessAdjustment?: number;
        snapshotVersion?: string;
        stakedNodesOverrides?: string;
        towerStorage?: string;
        tpuCoalesceMs?: number;
        tpuConnectionPoolSize?: number;
        tpuDisableQuic?: boolean;
        tpuEnableUdp?: boolean;
        tvuReceiveThreads?: number;
        unifiedSchedulerHandlerThreads?: number;
        useSnapshotArchivesAtStartup?: string;
        waitForSupermajority?: number;
        walRecoveryMode: string;
    }
    interface KeyPairs {
        identity: string;
        voteAccount: string;
    }
    interface Metrics {
        database: string;
        password: string;
        url: string;
        user: string;
    }
    interface ShutdownPolicy {
        force?: boolean;
        maxDelinquentStake?: number;
        minIdleTime?: number;
        skipHealthCheck?: boolean;
        skipNewSnapshotCheck?: boolean;
    }
    interface StartupPolicy {
        waitForRPCHealth?: boolean;
    }
    interface TimeoutConfig {
        rpcServiceTimeout?: number;
    }
}
export declare namespace deb {
    interface Package {
        name: string;
        path?: string;
        targetRelease?: string;
        version?: string;
    }
    interface PackageConfig {
        additional?: string[];
        override?: outputs.deb.Package[];
    }
}
export declare namespace explorer {
    interface ExplorerFlags {
        hostname?: string;
        keepAliveTimeout?: number;
        port?: number;
    }
}
export declare namespace faucet {
    interface FaucetFlags {
        allowIPs?: string[];
        perRequestCap?: number;
        perTimeCap?: number;
        sliceSeconds?: number;
    }
}
export declare namespace firedancer {
    interface Config {
        consensus?: outputs.firedancer.ConfigConsensus;
        dynamicPortRange?: string;
        extraConfig?: string[];
        gossip?: outputs.firedancer.ConfigGossip;
        hugetlbfs?: outputs.firedancer.ConfigHugeTLBFS;
        layout?: outputs.firedancer.ConfigLayout;
        ledger?: outputs.firedancer.ConfigLedger;
        log?: outputs.firedancer.ConfigLog;
        name?: string;
        reporting?: outputs.firedancer.ConfigReporting;
        rpc?: outputs.firedancer.ConfigRPC;
        scratchDirectory?: string;
        snapshots?: outputs.firedancer.ConfigSnapshots;
        user?: string;
    }
    interface ConfigConsensus {
        authorizedVoterPaths?: string[];
        expectedBankHash?: string;
        expectedGenesisHash?: string;
        expectedShredVersion?: number;
        genesisFetch?: boolean;
        hardForkAtSlots?: string[];
        identityPath?: string;
        knownValidators?: string[];
        osNetworkLimitsTest?: boolean;
        pohSpeedTest?: boolean;
        snapshotFetch?: boolean;
        voteAccountPath?: string;
        waitForSupermajorityAtSlot?: number;
        waitForVoteToStartLeader?: boolean;
    }
    interface ConfigGossip {
        entrypoints?: string[];
        host?: string;
        port?: number;
        portCheck?: boolean;
    }
    interface ConfigHugeTLBFS {
        mountPath?: string;
    }
    interface ConfigLayout {
        affinity?: string;
        agaveAffinity?: string;
        bankTileCount?: number;
        netTileCount?: number;
        quicTileCount?: number;
        resolvTileCount?: number;
        shredTileCount?: number;
        verifyTileCount?: number;
    }
    interface ConfigLedger {
        accountIndexExcludeKeys?: string[];
        accountIndexIncludeKeys?: string[];
        accountIndexes?: string[];
        accountsPath?: string;
        limitSize?: number;
        path?: string;
        requireTower?: boolean;
        snapshotArchiveFormat?: string;
    }
    interface ConfigLog {
        colorize?: string;
        levelFlush?: string;
        levelLogfile?: string;
        levelStderr?: string;
        path?: string;
    }
    interface ConfigRPC {
        bigtableLedgerStorage?: boolean;
        extendedTxMetadataStorage?: boolean;
        fullApi?: boolean;
        onlyKnown?: boolean;
        port?: number;
        private?: boolean;
        pubsubEnableBlockSubscription?: boolean;
        pubsubEnableVoteSubscription?: boolean;
        transactionHistory?: boolean;
    }
    interface ConfigReporting {
        solanaMetricsConfig?: string;
    }
    interface ConfigSnapshots {
        fullSnapshotIntervalSlots?: number;
        incrementalPath?: string;
        incrementalSnapshotIntervalSlots?: number;
        incrementalSnapshots?: boolean;
        maximumFullSnapshotsToRetain?: number;
        maximumIncrementalSnapshotsToRetain?: number;
        minimumSnapshotDownloadSpeed?: number;
        path?: string;
    }
    interface KeyPairs {
        identity: string;
        voteAccount: string;
    }
}
export declare namespace genesis {
    interface BootstrapAccount {
        balanceLamports?: number;
        identityPubkey: string;
        stakeLamports?: number;
        stakePubkey: string;
        votePubkey: string;
    }
    interface GenesisFlags {
        bootstrapStakeAuthorizedPubkey?: string;
        bootstrapValidatorLamports?: number;
        bootstrapValidatorStakeLamports?: number;
        clusterType?: string;
        creationTime?: string;
        deactivateFeatures?: string[];
        enableWarmupEpochs?: boolean;
        extraFlags?: string[];
        faucetLamports?: number;
        faucetPubkey?: string;
        feeBurnPercentage?: number;
        hashesPerTick?: string;
        identityPubkey: string;
        inflation?: string;
        lamportsPerByteYear?: number;
        ledgerPath: string;
        maxGenesisArchiveUnpackedSize?: number;
        rentBurnPercentage?: number;
        rentExemptionThreshold?: number;
        slotsPerEpoch?: number;
        stakePubkey: string;
        targetLamportsPerSignature?: number;
        targetSignaturesPerSlot?: number;
        targetTickDuration?: number;
        ticksPerSlot?: number;
        url?: string;
        voteCommissionPercentage?: number;
        votePubkey: string;
    }
    interface PrimordialAccount {
        data?: string;
        executable?: boolean;
        lamports: number;
        owner?: string;
        pubkey: string;
    }
}
export declare namespace runner {
    interface Config {
        aptLockTimeout?: number;
        packageConfig?: outputs.deb.PackageConfig;
    }
}
export declare namespace solana {
    interface Environment {
        rpcURL: string;
    }
    interface StakeAccountKeyPairs {
        stakeAccount: string;
        voteAccount: string;
    }
    interface TxnOptions {
        blockHash?: string;
        commitment?: string;
        feePayer?: string;
        from?: string;
        keyPair?: string;
        nonce?: string;
        nonceAuthority?: string;
        signer?: string[];
        url?: string;
        withComputeUnitPrice?: number;
        withMemo?: string;
        ws?: string;
    }
    interface ValidatorInfo {
        details?: string;
        iconURL?: string;
        name: string;
        website?: string;
    }
    interface VoteAccountKeyPairs {
        authWithdrawer: string;
        identity: string;
        voteAccount: string;
    }
}
export declare namespace ssh {
    /**
     * Instructions for how to connect to a remote endpoint.
     */
    interface Connection {
        /**
         * SSH Agent socket path. Default to environment variable SSH_AUTH_SOCK if present.
         */
        agentSocketPath?: string;
        /**
         * Max allowed errors on trying to dial the remote host. -1 set count to unlimited. Default value is 10.
         */
        dialErrorLimit?: number;
        /**
         * The address of the resource to connect to.
         */
        host: string;
        /**
         * The password we should use for the connection.
         */
        password?: string;
        /**
         * Max number of seconds for each dial attempt. 0 implies no maximum. Default value is 15 seconds.
         */
        perDialTimeout?: number;
        /**
         * The port to connect to. Defaults to 22.
         */
        port?: number;
        /**
         * The contents of an SSH key to use for the connection. This takes preference over the password if provided.
         */
        privateKey?: string;
        /**
         * The password to use in case the private key is encrypted.
         */
        privateKeyPassword?: string;
        /**
         * The connection settings for the bastion/proxy host.
         */
        proxy?: outputs.ssh.ProxyConnection;
        /**
         * The user that we should use for the connection.
         */
        user?: string;
    }
    /**
     * connectionProvideDefaults sets the appropriate defaults for Connection
     */
    function connectionProvideDefaults(val: Connection): Connection;
    /**
     * Instructions for how to connect to a remote endpoint via a bastion host.
     */
    interface ProxyConnection {
        /**
         * SSH Agent socket path. Default to environment variable SSH_AUTH_SOCK if present.
         */
        agentSocketPath?: string;
        /**
         * Max allowed errors on trying to dial the remote host. -1 set count to unlimited. Default value is 10.
         */
        dialErrorLimit?: number;
        /**
         * The address of the bastion host to connect to.
         */
        host: string;
        /**
         * The password we should use for the connection to the bastion host.
         */
        password?: string;
        /**
         * Max number of seconds for each dial attempt. 0 implies no maximum. Default value is 15 seconds.
         */
        perDialTimeout?: number;
        /**
         * The port of the bastion host to connect to.
         */
        port?: number;
        /**
         * The contents of an SSH key to use for the connection. This takes preference over the password if provided.
         */
        privateKey?: string;
        /**
         * The password to use in case the private key is encrypted.
         */
        privateKeyPassword?: string;
        /**
         * The user that we should use for the connection to the bastion host.
         */
        user?: string;
    }
    /**
     * proxyConnectionProvideDefaults sets the appropriate defaults for ProxyConnection
     */
    function proxyConnectionProvideDefaults(val: ProxyConnection): ProxyConnection;
}
export declare namespace tuner {
    interface TunerFsParams {
        fsNrOpen?: number;
    }
    interface TunerKernelParams {
        kernelHungTaskTimeoutSecs?: number;
        kernelNmiWatchdog?: number;
        kernelPidMax?: number;
        kernelSchedMinGranularityNs?: number;
        kernelSchedWakeupGranularityNs?: number;
        kernelTimerMigration?: number;
    }
    interface TunerNetParams {
        netCoreRmemDefault?: number;
        netCoreRmemMax?: number;
        netCoreWmemDefault?: number;
        netCoreWmemMax?: number;
        netIpv4TcpCongestionControl?: string;
        netIpv4TcpFastopen?: number;
        netIpv4TcpLowLatency?: number;
        netIpv4TcpModerateRcvbuf?: number;
        netIpv4TcpNoMetricsSave?: number;
        netIpv4TcpRmem?: string;
        netIpv4TcpSack?: number;
        netIpv4TcpTimestamps?: number;
        netIpv4TcpTwReuse?: number;
        netIpv4TcpWmem?: string;
    }
    interface TunerParams {
        cpuGovernor?: enums.tuner.CpuGovernor;
        fs?: outputs.tuner.TunerFsParams;
        kernel?: outputs.tuner.TunerKernelParams;
        net?: outputs.tuner.TunerNetParams;
        vm?: outputs.tuner.TunerVmParams;
    }
    interface TunerVmParams {
        vmDirtyBackgroundRatio?: number;
        vmDirtyExpireCentisecs?: number;
        vmDirtyRatio?: number;
        vmDirtyWritebackCentisecs?: number;
        vmDirtytimeExpireSeconds?: number;
        vmMaxMapCount?: number;
        vmMinFreeKbytes?: number;
        vmStatInterval?: number;
        vmSwappiness?: number;
    }
}
export declare namespace watchtower {
    interface DiscordConfig {
        webhookUrl: string;
    }
    interface NotificationConfig {
        discord?: outputs.watchtower.DiscordConfig;
        pagerDuty?: outputs.watchtower.PagerDutyConfig;
        slack?: outputs.watchtower.SlackConfig;
        telegram?: outputs.watchtower.TelegramConfig;
        twilio?: outputs.watchtower.TwilioConfig;
    }
    interface PagerDutyConfig {
        integrationKey: string;
    }
    interface SlackConfig {
        webhookUrl: string;
    }
    interface TelegramConfig {
        botToken: string;
        chatId: string;
    }
    interface TwilioConfig {
        accountSid: string;
        authToken: string;
        fromNumber: string;
        toNumber: string;
    }
    interface WatchtowerFlags {
        activeStakeAlertThreshold?: number;
        ignoreHttpBadGateway?: boolean;
        interval?: number;
        minimumValidatorIdentityBalance?: number;
        monitorActiveStake?: boolean;
        nameSuffix?: string;
        rpcTimeout?: number;
        unhealthyThreshold?: number;
        validatorIdentity: string[];
    }
}
